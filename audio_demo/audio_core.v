// -------------------------------------------------------------
// 
// File Name: /home/shahryar/Desktop/ECE532/TestHDLMatlab/hdlsrc/audio_setup/audio_core.v
// Created: 2020-03-22 15:42:36
// 
// Generated by MATLAB 9.7 and HDL Coder 3.15
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1e-08
// Target subsystem base rate: 1e-08
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1e-08
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// out_PDM                       ce_out        1e-08
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: audio_core
// Source Path: audio_setup/audio_core
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module audio_core
          (clk,
           reset,
           clk_enable,
           note_c4,
           note_d4,
           note_e4,
           note_f4,
           run_drum,
           volume_ctrl,
           ce_out,
           out_PDM);


  input   clk;
  input   reset;
  input   clk_enable;
  input   note_c4;
  input   note_d4;
  input   note_e4;
  input   note_f4;
  input   run_drum;
  input   [7:0] volume_ctrl;  // ufix8_En8
  output  ce_out;
  output  out_PDM;


  wire enb;
  reg  [0:9] delayMatch_reg;  // ufix1 [10]
  wire [0:9] delayMatch_reg_next;  // ufix1 [10]
  wire run_drum_1;
  wire switch_compare_1;
  wire Logical_Operator_out1;
  wire signed [31:0] Constant_out1;  // sfix32_En30
  wire signed [43:0] Drum_out1;  // sfix44_En40
  wire signed [31:0] Data_Type_Conversion6_out1;  // sfix32_En30
  wire signed [31:0] Switch_out1;  // sfix32_En30
  wire Logical_Operator1_out1;
  reg [31:0] HDL_Counter4_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion5_out1;  // sfix32_En28
  wire signed [31:0] Sin3_out1;  // sfix32_En30
  wire Logical_Operator2_out1;
  reg [31:0] HDL_Counter1_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion3_out1;  // sfix32_En28
  wire signed [31:0] Sin2_out1;  // sfix32_En30
  wire Logical_Operator3_out1;
  reg [31:0] HDL_Counter2_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion2_out1;  // sfix32_En28
  wire signed [31:0] Sin1_out1;  // sfix32_En30
  wire Logical_Operator4_out1;
  reg [31:0] HDL_Counter3_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion4_out1;  // sfix32_En28
  wire signed [31:0] Sin_out1;  // sfix32_En30
  wire signed [33:0] Sum_add_cast;  // sfix34_En30
  wire signed [33:0] Sum_add_cast_1;  // sfix34_En30
  wire signed [33:0] Sum_add_temp;  // sfix34_En30
  wire signed [33:0] Sum_add_cast_2;  // sfix34_En30
  wire signed [33:0] Sum_add_temp_1;  // sfix34_En30
  wire signed [33:0] Sum_add_cast_3;  // sfix34_En30
  wire signed [33:0] Sum_out1;  // sfix34_En30
  wire signed [67:0] Gain1_out1;  // sfix68_En64
  wire signed [31:0] Data_Type_Conversion7_out1;  // sfix32_En30
  reg signed [31:0] delayMatch1_reg [0:3];  // sfix32 [4]
  wire signed [31:0] delayMatch1_reg_next [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Data_Type_Conversion7_out1_1;  // sfix32_En30
  wire signed [32:0] Sum1_add_cast;  // sfix33_En30
  wire signed [32:0] Sum1_add_cast_1;  // sfix33_En30
  wire signed [32:0] Sum1_out1;  // sfix33_En30
  wire signed [65:0] Gain_out1;  // sfix66_En62
  reg signed [65:0] Gain_out1_1;  // sfix66_En62
  reg [7:0] HwModeRegister1_reg [0:10];  // ufix8 [11]
  wire [7:0] HwModeRegister1_reg_next [0:10];  // ufix8_En8 [11]
  wire [7:0] volume_ctrl_1;  // ufix8_En8
  wire signed [8:0] Product_cast;  // sfix9_En8
  wire signed [74:0] Product_mul_temp;  // sfix75_En70
  wire signed [73:0] Product_out1;  // sfix74_En70
  reg signed [73:0] Product_out1_1;  // sfix74_En70
  wire signed [23:0] Data_Type_Conversion1_out1;  // sfix24_En14
  wire DeltaSigma_out1;


  assign enb = clk_enable;

  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg[0] <= 1'b0;
        delayMatch_reg[1] <= 1'b0;
        delayMatch_reg[2] <= 1'b0;
        delayMatch_reg[3] <= 1'b0;
        delayMatch_reg[4] <= 1'b0;
        delayMatch_reg[5] <= 1'b0;
        delayMatch_reg[6] <= 1'b0;
        delayMatch_reg[7] <= 1'b0;
        delayMatch_reg[8] <= 1'b0;
        delayMatch_reg[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
          delayMatch_reg[5] <= delayMatch_reg_next[5];
          delayMatch_reg[6] <= delayMatch_reg_next[6];
          delayMatch_reg[7] <= delayMatch_reg_next[7];
          delayMatch_reg[8] <= delayMatch_reg_next[8];
          delayMatch_reg[9] <= delayMatch_reg_next[9];
        end
      end
    end

  assign run_drum_1 = delayMatch_reg[9];
  assign delayMatch_reg_next[0] = run_drum;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];
  assign delayMatch_reg_next[5] = delayMatch_reg[4];
  assign delayMatch_reg_next[6] = delayMatch_reg[5];
  assign delayMatch_reg_next[7] = delayMatch_reg[6];
  assign delayMatch_reg_next[8] = delayMatch_reg[7];
  assign delayMatch_reg_next[9] = delayMatch_reg[8];



  assign switch_compare_1 = run_drum_1 > 1'b0;



  assign Logical_Operator_out1 =  ~ run_drum;


  assign Constant_out1 = 32'sb00000000000000000000000000000000;


  Drum u_Drum (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .enb_1(run_drum),
               .rst(Logical_Operator_out1),
               .Out1(Drum_out1)  // sfix44_En40
               );
  assign Data_Type_Conversion6_out1 = Drum_out1[41:10];


  assign Switch_out1 = (switch_compare_1 == 1'b0 ? Constant_out1 :
              Data_Type_Conversion6_out1);


  assign Logical_Operator1_out1 =  ~ note_c4;


  // Count limited, Unsigned Counter
  //  initial value   = 3451654029
  //  step value      = 4413
  //  count to value  = 843313268
  always @(posedge clk or posedge reset)
    begin : HDL_Counter4_process
      if (reset == 1'b1) begin
        HDL_Counter4_out1 <= 32'b11001101101111000000111110001101;
      end
      else begin
        if (enb) begin
          if (Logical_Operator1_out1 == 1'b1) begin
            HDL_Counter4_out1 <= 32'b11001101101111000000111110001101;
          end
          else if (note_c4 == 1'b1) begin
            if (HDL_Counter4_out1 == 32'b00110010010000111111000001110100) begin
              HDL_Counter4_out1 <= 32'b11001101101111000000111110001101;
            end
            else begin
              HDL_Counter4_out1 <= HDL_Counter4_out1 + 32'b00000000000000000001000100111101;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion5_out1 = HDL_Counter4_out1;


  Sin3 u_Sin3 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion5_out1),  // sfix32_En28
               .sin(Sin3_out1)  // sfix32_En30
               );
  assign Logical_Operator2_out1 =  ~ note_d4;


  // Count limited, Unsigned Counter
  //  initial value   = 3451654657
  //  step value      = 4953
  //  count to value  = 843312639
  always @(posedge clk or posedge reset)
    begin : HDL_Counter1_process
      if (reset == 1'b1) begin
        HDL_Counter1_out1 <= 32'b11001101101111000001001000000001;
      end
      else begin
        if (enb) begin
          if (Logical_Operator2_out1 == 1'b1) begin
            HDL_Counter1_out1 <= 32'b11001101101111000001001000000001;
          end
          else if (note_d4 == 1'b1) begin
            if (HDL_Counter1_out1 == 32'b00110010010000111110110111111111) begin
              HDL_Counter1_out1 <= 32'b11001101101111000001001000000001;
            end
            else begin
              HDL_Counter1_out1 <= HDL_Counter1_out1 + 32'b00000000000000000001001101011001;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion3_out1 = HDL_Counter1_out1;


  Sin2 u_Sin2 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion3_out1),  // sfix32_En28
               .sin(Sin2_out1)  // sfix32_En30
               );
  assign Logical_Operator3_out1 =  ~ note_e4;


  // Count limited, Unsigned Counter
  //  initial value   = 3451654296
  //  step value      = 5560
  //  count to value  = 843313000
  always @(posedge clk or posedge reset)
    begin : HDL_Counter2_process
      if (reset == 1'b1) begin
        HDL_Counter2_out1 <= 32'b11001101101111000001000010011000;
      end
      else begin
        if (enb) begin
          if (Logical_Operator3_out1 == 1'b1) begin
            HDL_Counter2_out1 <= 32'b11001101101111000001000010011000;
          end
          else if (note_e4 == 1'b1) begin
            if (HDL_Counter2_out1 == 32'b00110010010000111110111101101000) begin
              HDL_Counter2_out1 <= 32'b11001101101111000001000010011000;
            end
            else begin
              HDL_Counter2_out1 <= HDL_Counter2_out1 + 32'b00000000000000000001010110111000;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion2_out1 = HDL_Counter2_out1;


  Sin1 u_Sin1 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion2_out1),  // sfix32_En28
               .sin(Sin1_out1)  // sfix32_En30
               );
  assign Logical_Operator4_out1 =  ~ note_f4;


  // Count limited, Unsigned Counter
  //  initial value   = 3451654766
  //  step value      = 5890
  //  count to value  = 843312530
  always @(posedge clk or posedge reset)
    begin : HDL_Counter3_process
      if (reset == 1'b1) begin
        HDL_Counter3_out1 <= 32'b11001101101111000001001001101110;
      end
      else begin
        if (enb) begin
          if (Logical_Operator4_out1 == 1'b1) begin
            HDL_Counter3_out1 <= 32'b11001101101111000001001001101110;
          end
          else if (note_f4 == 1'b1) begin
            if (HDL_Counter3_out1 == 32'b00110010010000111110110110010010) begin
              HDL_Counter3_out1 <= 32'b11001101101111000001001001101110;
            end
            else begin
              HDL_Counter3_out1 <= HDL_Counter3_out1 + 32'b00000000000000000001011100000010;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion4_out1 = HDL_Counter3_out1;


  Sin u_Sin (.clk(clk),
             .reset(reset),
             .enb(clk_enable),
             .angle(Data_Type_Conversion4_out1),  // sfix32_En28
             .sin_1(Sin_out1)  // sfix32_En30
             );
  assign Sum_add_cast = {{2{Sin3_out1[31]}}, Sin3_out1};
  assign Sum_add_cast_1 = {{2{Sin2_out1[31]}}, Sin2_out1};
  assign Sum_add_temp = Sum_add_cast + Sum_add_cast_1;
  assign Sum_add_cast_2 = {{2{Sin1_out1[31]}}, Sin1_out1};
  assign Sum_add_temp_1 = Sum_add_temp + Sum_add_cast_2;
  assign Sum_add_cast_3 = {{2{Sin_out1[31]}}, Sin_out1};
  assign Sum_out1 = Sum_add_temp_1 + Sum_add_cast_3;


  assign Gain1_out1 = {{2{Sum_out1[33]}}, {Sum_out1, 32'b00000000000000000000000000000000}};


  assign Data_Type_Conversion7_out1 = Gain1_out1[65:34];


  always @(posedge clk or posedge reset)
    begin : delayMatch1_process
      if (reset == 1'b1) begin
        delayMatch1_reg[0] <= 32'sb00000000000000000000000000000000;
        delayMatch1_reg[1] <= 32'sb00000000000000000000000000000000;
        delayMatch1_reg[2] <= 32'sb00000000000000000000000000000000;
        delayMatch1_reg[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= delayMatch1_reg_next[0];
          delayMatch1_reg[1] <= delayMatch1_reg_next[1];
          delayMatch1_reg[2] <= delayMatch1_reg_next[2];
          delayMatch1_reg[3] <= delayMatch1_reg_next[3];
        end
      end
    end

  assign Data_Type_Conversion7_out1_1 = delayMatch1_reg[3];
  assign delayMatch1_reg_next[0] = Data_Type_Conversion7_out1;
  assign delayMatch1_reg_next[1] = delayMatch1_reg[0];
  assign delayMatch1_reg_next[2] = delayMatch1_reg[1];
  assign delayMatch1_reg_next[3] = delayMatch1_reg[2];



  assign Sum1_add_cast = {Switch_out1[31], Switch_out1};
  assign Sum1_add_cast_1 = {Data_Type_Conversion7_out1_1[31], Data_Type_Conversion7_out1_1};
  assign Sum1_out1 = Sum1_add_cast + Sum1_add_cast_1;


  assign Gain_out1 = {{2{Sum1_out1[32]}}, {Sum1_out1, 31'b0000000000000000000000000000000}};


  always @(posedge clk or posedge reset)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        Gain_out1_1 <= 66'sh00000000000000000;
      end
      else begin
        if (enb) begin
          Gain_out1_1 <= Gain_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        HwModeRegister1_reg[0] <= 8'b00000000;
        HwModeRegister1_reg[1] <= 8'b00000000;
        HwModeRegister1_reg[2] <= 8'b00000000;
        HwModeRegister1_reg[3] <= 8'b00000000;
        HwModeRegister1_reg[4] <= 8'b00000000;
        HwModeRegister1_reg[5] <= 8'b00000000;
        HwModeRegister1_reg[6] <= 8'b00000000;
        HwModeRegister1_reg[7] <= 8'b00000000;
        HwModeRegister1_reg[8] <= 8'b00000000;
        HwModeRegister1_reg[9] <= 8'b00000000;
        HwModeRegister1_reg[10] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          HwModeRegister1_reg[0] <= HwModeRegister1_reg_next[0];
          HwModeRegister1_reg[1] <= HwModeRegister1_reg_next[1];
          HwModeRegister1_reg[2] <= HwModeRegister1_reg_next[2];
          HwModeRegister1_reg[3] <= HwModeRegister1_reg_next[3];
          HwModeRegister1_reg[4] <= HwModeRegister1_reg_next[4];
          HwModeRegister1_reg[5] <= HwModeRegister1_reg_next[5];
          HwModeRegister1_reg[6] <= HwModeRegister1_reg_next[6];
          HwModeRegister1_reg[7] <= HwModeRegister1_reg_next[7];
          HwModeRegister1_reg[8] <= HwModeRegister1_reg_next[8];
          HwModeRegister1_reg[9] <= HwModeRegister1_reg_next[9];
          HwModeRegister1_reg[10] <= HwModeRegister1_reg_next[10];
        end
      end
    end

  assign volume_ctrl_1 = HwModeRegister1_reg[10];
  assign HwModeRegister1_reg_next[0] = volume_ctrl;
  assign HwModeRegister1_reg_next[1] = HwModeRegister1_reg[0];
  assign HwModeRegister1_reg_next[2] = HwModeRegister1_reg[1];
  assign HwModeRegister1_reg_next[3] = HwModeRegister1_reg[2];
  assign HwModeRegister1_reg_next[4] = HwModeRegister1_reg[3];
  assign HwModeRegister1_reg_next[5] = HwModeRegister1_reg[4];
  assign HwModeRegister1_reg_next[6] = HwModeRegister1_reg[5];
  assign HwModeRegister1_reg_next[7] = HwModeRegister1_reg[6];
  assign HwModeRegister1_reg_next[8] = HwModeRegister1_reg[7];
  assign HwModeRegister1_reg_next[9] = HwModeRegister1_reg[8];
  assign HwModeRegister1_reg_next[10] = HwModeRegister1_reg[9];



  assign Product_cast = {1'b0, volume_ctrl_1};
  assign Product_mul_temp = Gain_out1_1 * Product_cast;
  assign Product_out1 = Product_mul_temp[73:0];


  always @(posedge clk or posedge reset)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        Product_out1_1 <= 74'sh0000000000000000000;
      end
      else begin
        if (enb) begin
          Product_out1_1 <= Product_out1;
        end
      end
    end



  assign Data_Type_Conversion1_out1 = {{6{Product_out1_1[73]}}, Product_out1_1[73:56]};


  DeltaSigma u_DeltaSigma (.clk(clk),
                           .reset(reset),
                           .enb(clk_enable),
                           .Mixed_Signal(Data_Type_Conversion1_out1),  // sfix24_En14
                           .Output_rsvd(DeltaSigma_out1)
                           );
  assign out_PDM = DeltaSigma_out1;

  assign ce_out = clk_enable;

endmodule  // audio_core

