// -------------------------------------------------------------
// 
// File Name: /home/shahryar/Desktop/ECE532/TestHDLMatlab/hdlsrc/test2/audio_core.v
// Created: 2020-03-19 13:17:35
// 
// Generated by MATLAB 9.7 and HDL Coder 3.15
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1e-08
// Target subsystem base rate: 1e-08
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1e-08
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// out_PDM                       ce_out        1e-08
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: audio_core
// Source Path: test2/audio_core
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module audio_core
          (clk,
           reset,
           clk_enable,
           note_c6,
           note_d6,
           note_e6,
           note_f6,
           run_drum,
           volume_ctrl,
           ce_out,
           out_PDM);


  input   clk;
  input   reset;
  input   clk_enable;
  input   note_c6;
  input   note_d6;
  input   note_e6;
  input   note_f6;
  input   run_drum;
  input   [7:0] volume_ctrl;  // ufix8_En8
  output  ce_out;
  output  out_PDM;


  wire enb;
  wire signed [34:0] kconst;  // sfix35_En36
  reg signed [34:0] kconst_1;  // sfix35_En36
  reg  [0:9] delayMatch_reg;  // ufix1 [10]
  wire [0:9] delayMatch_reg_next;  // ufix1 [10]
  wire run_drum_1;
  wire switch_compare_1;
  wire Logical_Operator_out1;
  wire signed [31:0] Constant_out1;  // sfix32_En30
  wire signed [43:0] Drum_out1;  // sfix44_En40
  wire signed [31:0] Data_Type_Conversion6_out1;  // sfix32_En30
  wire signed [31:0] Switch_out1;  // sfix32_En30
  wire Logical_Operator1_out1;
  reg [31:0] HDL_Counter4_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion5_out1;  // sfix32_En28
  wire signed [31:0] Sin3_out1;  // sfix32_En30
  reg signed [31:0] delayMatch1_reg [0:3];  // sfix32 [4]
  wire signed [31:0] delayMatch1_reg_next [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Sin3_out1_1;  // sfix32_En30
  wire Logical_Operator2_out1;
  reg [31:0] HDL_Counter1_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion3_out1;  // sfix32_En28
  wire signed [31:0] Sin2_out1;  // sfix32_En30
  reg signed [31:0] delayMatch2_reg [0:3];  // sfix32 [4]
  wire signed [31:0] delayMatch2_reg_next [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Sin2_out1_1;  // sfix32_En30
  wire Logical_Operator3_out1;
  reg [31:0] HDL_Counter2_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion2_out1;  // sfix32_En28
  wire signed [31:0] Sin1_out1;  // sfix32_En30
  reg signed [31:0] delayMatch3_reg [0:3];  // sfix32 [4]
  wire signed [31:0] delayMatch3_reg_next [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Sin1_out1_1;  // sfix32_En30
  wire Logical_Operator4_out1;
  reg [31:0] HDL_Counter3_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion4_out1;  // sfix32_En28
  wire signed [31:0] Sin_out1;  // sfix32_En30
  reg signed [31:0] delayMatch4_reg [0:3];  // sfix32 [4]
  wire signed [31:0] delayMatch4_reg_next [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Sin_out1_1;  // sfix32_En30
  wire signed [34:0] Sum_add_cast;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_1;  // sfix35_En30
  wire signed [34:0] Sum_add_temp;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_2;  // sfix35_En30
  wire signed [34:0] Sum_add_temp_1;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_3;  // sfix35_En30
  wire signed [34:0] Sum_add_temp_2;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_4;  // sfix35_En30
  wire signed [34:0] Sum_out1;  // sfix35_En30
  reg signed [34:0] Sum_out1_1;  // sfix35_En30
  wire signed [69:0] Gain_out1;  // sfix70_En66
  reg signed [69:0] HwModeRegister_reg [0:1];  // sfix70 [2]
  wire signed [69:0] HwModeRegister_reg_next [0:1];  // sfix70_En66 [2]
  wire signed [69:0] Gain_out1_1;  // sfix70_En66
  reg [7:0] HwModeRegister1_reg [0:12];  // ufix8 [13]
  wire [7:0] HwModeRegister1_reg_next [0:12];  // ufix8_En8 [13]
  wire [7:0] volume_ctrl_1;  // ufix8_En8
  wire signed [8:0] Product_cast;  // sfix9_En8
  wire signed [78:0] Product_mul_temp;  // sfix79_En74
  wire signed [77:0] Product_out1;  // sfix78_En74
  reg signed [77:0] Product_out1_1;  // sfix78_En74
  wire signed [23:0] Data_Type_Conversion1_out1;  // sfix24_En14
  wire DeltaSigma_out1;


  assign kconst = 35'sh333333333;



  assign enb = clk_enable;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister2_process
      if (reset == 1'b1) begin
        kconst_1 <= 35'sh000000000;
      end
      else begin
        if (enb) begin
          kconst_1 <= kconst;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg[0] <= 1'b0;
        delayMatch_reg[1] <= 1'b0;
        delayMatch_reg[2] <= 1'b0;
        delayMatch_reg[3] <= 1'b0;
        delayMatch_reg[4] <= 1'b0;
        delayMatch_reg[5] <= 1'b0;
        delayMatch_reg[6] <= 1'b0;
        delayMatch_reg[7] <= 1'b0;
        delayMatch_reg[8] <= 1'b0;
        delayMatch_reg[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
          delayMatch_reg[5] <= delayMatch_reg_next[5];
          delayMatch_reg[6] <= delayMatch_reg_next[6];
          delayMatch_reg[7] <= delayMatch_reg_next[7];
          delayMatch_reg[8] <= delayMatch_reg_next[8];
          delayMatch_reg[9] <= delayMatch_reg_next[9];
        end
      end
    end

  assign run_drum_1 = delayMatch_reg[9];
  assign delayMatch_reg_next[0] = run_drum;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];
  assign delayMatch_reg_next[5] = delayMatch_reg[4];
  assign delayMatch_reg_next[6] = delayMatch_reg[5];
  assign delayMatch_reg_next[7] = delayMatch_reg[6];
  assign delayMatch_reg_next[8] = delayMatch_reg[7];
  assign delayMatch_reg_next[9] = delayMatch_reg[8];



  assign switch_compare_1 = run_drum_1 > 1'b0;



  assign Logical_Operator_out1 =  ~ run_drum;


  assign Constant_out1 = 32'sb00000000000000000000000000000000;


  Drum u_Drum (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .enb_1(run_drum),
               .rst(Logical_Operator_out1),
               .Out1(Drum_out1)  // sfix44_En40
               );
  assign Data_Type_Conversion6_out1 = Drum_out1[41:10];


  assign Switch_out1 = (switch_compare_1 == 1'b0 ? Constant_out1 :
              Data_Type_Conversion6_out1);


  assign Logical_Operator1_out1 =  ~ note_c6;


  // Count limited, Unsigned Counter
  //  initial value   = 3451655469
  //  step value      = 17651
  //  count to value  = 843311827
  always @(posedge clk or posedge reset)
    begin : HDL_Counter4_process
      if (reset == 1'b1) begin
        HDL_Counter4_out1 <= 32'b11001101101111000001010100101101;
      end
      else begin
        if (enb) begin
          if (Logical_Operator1_out1 == 1'b1) begin
            HDL_Counter4_out1 <= 32'b11001101101111000001010100101101;
          end
          else if (note_c6 == 1'b1) begin
            if (HDL_Counter4_out1 == 32'b00110010010000111110101011010011) begin
              HDL_Counter4_out1 <= 32'b11001101101111000001010100101101;
            end
            else begin
              HDL_Counter4_out1 <= HDL_Counter4_out1 + 32'b00000000000000000100010011110011;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion5_out1 = HDL_Counter4_out1;


  Sin3 u_Sin3 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion5_out1),  // sfix32_En28
               .sin(Sin3_out1)  // sfix32_En30
               );
  always @(posedge clk or posedge reset)
    begin : delayMatch1_process
      if (reset == 1'b1) begin
        delayMatch1_reg[0] <= 32'sb00000000000000000000000000000000;
        delayMatch1_reg[1] <= 32'sb00000000000000000000000000000000;
        delayMatch1_reg[2] <= 32'sb00000000000000000000000000000000;
        delayMatch1_reg[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= delayMatch1_reg_next[0];
          delayMatch1_reg[1] <= delayMatch1_reg_next[1];
          delayMatch1_reg[2] <= delayMatch1_reg_next[2];
          delayMatch1_reg[3] <= delayMatch1_reg_next[3];
        end
      end
    end

  assign Sin3_out1_1 = delayMatch1_reg[3];
  assign delayMatch1_reg_next[0] = Sin3_out1;
  assign delayMatch1_reg_next[1] = delayMatch1_reg[0];
  assign delayMatch1_reg_next[2] = delayMatch1_reg[1];
  assign delayMatch1_reg_next[3] = delayMatch1_reg[2];



  assign Logical_Operator2_out1 =  ~ note_d6;


  // Count limited, Unsigned Counter
  //  initial value   = 3451659610
  //  step value      = 19812
  //  count to value  = 843307686
  always @(posedge clk or posedge reset)
    begin : HDL_Counter1_process
      if (reset == 1'b1) begin
        HDL_Counter1_out1 <= 32'b11001101101111000010010101011010;
      end
      else begin
        if (enb) begin
          if (Logical_Operator2_out1 == 1'b1) begin
            HDL_Counter1_out1 <= 32'b11001101101111000010010101011010;
          end
          else if (note_d6 == 1'b1) begin
            if (HDL_Counter1_out1 == 32'b00110010010000111101101010100110) begin
              HDL_Counter1_out1 <= 32'b11001101101111000010010101011010;
            end
            else begin
              HDL_Counter1_out1 <= HDL_Counter1_out1 + 32'b00000000000000000100110101100100;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion3_out1 = HDL_Counter1_out1;


  Sin2 u_Sin2 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion3_out1),  // sfix32_En28
               .sin(Sin2_out1)  // sfix32_En30
               );
  always @(posedge clk or posedge reset)
    begin : delayMatch2_process
      if (reset == 1'b1) begin
        delayMatch2_reg[0] <= 32'sb00000000000000000000000000000000;
        delayMatch2_reg[1] <= 32'sb00000000000000000000000000000000;
        delayMatch2_reg[2] <= 32'sb00000000000000000000000000000000;
        delayMatch2_reg[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch2_reg[0] <= delayMatch2_reg_next[0];
          delayMatch2_reg[1] <= delayMatch2_reg_next[1];
          delayMatch2_reg[2] <= delayMatch2_reg_next[2];
          delayMatch2_reg[3] <= delayMatch2_reg_next[3];
        end
      end
    end

  assign Sin2_out1_1 = delayMatch2_reg[3];
  assign delayMatch2_reg_next[0] = Sin2_out1;
  assign delayMatch2_reg_next[1] = delayMatch2_reg[0];
  assign delayMatch2_reg_next[2] = delayMatch2_reg[1];
  assign delayMatch2_reg_next[3] = delayMatch2_reg[2];



  assign Logical_Operator3_out1 =  ~ note_e6;


  // Count limited, Unsigned Counter
  //  initial value   = 3451657860
  //  step value      = 22238
  //  count to value  = 843309436
  always @(posedge clk or posedge reset)
    begin : HDL_Counter2_process
      if (reset == 1'b1) begin
        HDL_Counter2_out1 <= 32'b11001101101111000001111010000100;
      end
      else begin
        if (enb) begin
          if (Logical_Operator3_out1 == 1'b1) begin
            HDL_Counter2_out1 <= 32'b11001101101111000001111010000100;
          end
          else if (note_e6 == 1'b1) begin
            if (HDL_Counter2_out1 == 32'b00110010010000111110000101111100) begin
              HDL_Counter2_out1 <= 32'b11001101101111000001111010000100;
            end
            else begin
              HDL_Counter2_out1 <= HDL_Counter2_out1 + 32'b00000000000000000101011011011110;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion2_out1 = HDL_Counter2_out1;


  Sin1 u_Sin1 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion2_out1),  // sfix32_En28
               .sin(Sin1_out1)  // sfix32_En30
               );
  always @(posedge clk or posedge reset)
    begin : delayMatch3_process
      if (reset == 1'b1) begin
        delayMatch3_reg[0] <= 32'sb00000000000000000000000000000000;
        delayMatch3_reg[1] <= 32'sb00000000000000000000000000000000;
        delayMatch3_reg[2] <= 32'sb00000000000000000000000000000000;
        delayMatch3_reg[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch3_reg[0] <= delayMatch3_reg_next[0];
          delayMatch3_reg[1] <= delayMatch3_reg_next[1];
          delayMatch3_reg[2] <= delayMatch3_reg_next[2];
          delayMatch3_reg[3] <= delayMatch3_reg_next[3];
        end
      end
    end

  assign Sin1_out1_1 = delayMatch3_reg[3];
  assign delayMatch3_reg_next[0] = Sin1_out1;
  assign delayMatch3_reg_next[1] = delayMatch3_reg[0];
  assign delayMatch3_reg_next[2] = delayMatch3_reg[1];
  assign delayMatch3_reg_next[3] = delayMatch3_reg[2];



  assign Logical_Operator4_out1 =  ~ note_f6;


  // Count limited, Unsigned Counter
  //  initial value   = 3451660204
  //  step value      = 23561
  //  count to value  = 843307093
  always @(posedge clk or posedge reset)
    begin : HDL_Counter3_process
      if (reset == 1'b1) begin
        HDL_Counter3_out1 <= 32'b11001101101111000010011110101100;
      end
      else begin
        if (enb) begin
          if (Logical_Operator4_out1 == 1'b1) begin
            HDL_Counter3_out1 <= 32'b11001101101111000010011110101100;
          end
          else if (note_f6 == 1'b1) begin
            if (HDL_Counter3_out1 == 32'b00110010010000111101100001010101) begin
              HDL_Counter3_out1 <= 32'b11001101101111000010011110101100;
            end
            else begin
              HDL_Counter3_out1 <= HDL_Counter3_out1 + 32'b00000000000000000101110000001001;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion4_out1 = HDL_Counter3_out1;


  Sin u_Sin (.clk(clk),
             .reset(reset),
             .enb(clk_enable),
             .angle(Data_Type_Conversion4_out1),  // sfix32_En28
             .sin_1(Sin_out1)  // sfix32_En30
             );
  always @(posedge clk or posedge reset)
    begin : delayMatch4_process
      if (reset == 1'b1) begin
        delayMatch4_reg[0] <= 32'sb00000000000000000000000000000000;
        delayMatch4_reg[1] <= 32'sb00000000000000000000000000000000;
        delayMatch4_reg[2] <= 32'sb00000000000000000000000000000000;
        delayMatch4_reg[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch4_reg[0] <= delayMatch4_reg_next[0];
          delayMatch4_reg[1] <= delayMatch4_reg_next[1];
          delayMatch4_reg[2] <= delayMatch4_reg_next[2];
          delayMatch4_reg[3] <= delayMatch4_reg_next[3];
        end
      end
    end

  assign Sin_out1_1 = delayMatch4_reg[3];
  assign delayMatch4_reg_next[0] = Sin_out1;
  assign delayMatch4_reg_next[1] = delayMatch4_reg[0];
  assign delayMatch4_reg_next[2] = delayMatch4_reg[1];
  assign delayMatch4_reg_next[3] = delayMatch4_reg[2];



  assign Sum_add_cast = {{3{Switch_out1[31]}}, Switch_out1};
  assign Sum_add_cast_1 = {{3{Sin3_out1_1[31]}}, Sin3_out1_1};
  assign Sum_add_temp = Sum_add_cast + Sum_add_cast_1;
  assign Sum_add_cast_2 = {{3{Sin2_out1_1[31]}}, Sin2_out1_1};
  assign Sum_add_temp_1 = Sum_add_temp + Sum_add_cast_2;
  assign Sum_add_cast_3 = {{3{Sin1_out1_1[31]}}, Sin1_out1_1};
  assign Sum_add_temp_2 = Sum_add_temp_1 + Sum_add_cast_3;
  assign Sum_add_cast_4 = {{3{Sin_out1_1[31]}}, Sin_out1_1};
  assign Sum_out1 = Sum_add_temp_2 + Sum_add_cast_4;


  always @(posedge clk or posedge reset)
    begin : HwModeRegister3_process
      if (reset == 1'b1) begin
        Sum_out1_1 <= 35'sh000000000;
      end
      else begin
        if (enb) begin
          Sum_out1_1 <= Sum_out1;
        end
      end
    end



  assign Gain_out1 = kconst_1 * Sum_out1_1;


  always @(posedge clk or posedge reset)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        HwModeRegister_reg[0] <= 70'sh000000000000000000;
        HwModeRegister_reg[1] <= 70'sh000000000000000000;
      end
      else begin
        if (enb) begin
          HwModeRegister_reg[0] <= HwModeRegister_reg_next[0];
          HwModeRegister_reg[1] <= HwModeRegister_reg_next[1];
        end
      end
    end

  assign Gain_out1_1 = HwModeRegister_reg[1];
  assign HwModeRegister_reg_next[0] = Gain_out1;
  assign HwModeRegister_reg_next[1] = HwModeRegister_reg[0];



  always @(posedge clk or posedge reset)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        HwModeRegister1_reg[0] <= 8'b00000000;
        HwModeRegister1_reg[1] <= 8'b00000000;
        HwModeRegister1_reg[2] <= 8'b00000000;
        HwModeRegister1_reg[3] <= 8'b00000000;
        HwModeRegister1_reg[4] <= 8'b00000000;
        HwModeRegister1_reg[5] <= 8'b00000000;
        HwModeRegister1_reg[6] <= 8'b00000000;
        HwModeRegister1_reg[7] <= 8'b00000000;
        HwModeRegister1_reg[8] <= 8'b00000000;
        HwModeRegister1_reg[9] <= 8'b00000000;
        HwModeRegister1_reg[10] <= 8'b00000000;
        HwModeRegister1_reg[11] <= 8'b00000000;
        HwModeRegister1_reg[12] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          HwModeRegister1_reg[0] <= HwModeRegister1_reg_next[0];
          HwModeRegister1_reg[1] <= HwModeRegister1_reg_next[1];
          HwModeRegister1_reg[2] <= HwModeRegister1_reg_next[2];
          HwModeRegister1_reg[3] <= HwModeRegister1_reg_next[3];
          HwModeRegister1_reg[4] <= HwModeRegister1_reg_next[4];
          HwModeRegister1_reg[5] <= HwModeRegister1_reg_next[5];
          HwModeRegister1_reg[6] <= HwModeRegister1_reg_next[6];
          HwModeRegister1_reg[7] <= HwModeRegister1_reg_next[7];
          HwModeRegister1_reg[8] <= HwModeRegister1_reg_next[8];
          HwModeRegister1_reg[9] <= HwModeRegister1_reg_next[9];
          HwModeRegister1_reg[10] <= HwModeRegister1_reg_next[10];
          HwModeRegister1_reg[11] <= HwModeRegister1_reg_next[11];
          HwModeRegister1_reg[12] <= HwModeRegister1_reg_next[12];
        end
      end
    end

  assign volume_ctrl_1 = HwModeRegister1_reg[12];
  assign HwModeRegister1_reg_next[0] = volume_ctrl;
  assign HwModeRegister1_reg_next[1] = HwModeRegister1_reg[0];
  assign HwModeRegister1_reg_next[2] = HwModeRegister1_reg[1];
  assign HwModeRegister1_reg_next[3] = HwModeRegister1_reg[2];
  assign HwModeRegister1_reg_next[4] = HwModeRegister1_reg[3];
  assign HwModeRegister1_reg_next[5] = HwModeRegister1_reg[4];
  assign HwModeRegister1_reg_next[6] = HwModeRegister1_reg[5];
  assign HwModeRegister1_reg_next[7] = HwModeRegister1_reg[6];
  assign HwModeRegister1_reg_next[8] = HwModeRegister1_reg[7];
  assign HwModeRegister1_reg_next[9] = HwModeRegister1_reg[8];
  assign HwModeRegister1_reg_next[10] = HwModeRegister1_reg[9];
  assign HwModeRegister1_reg_next[11] = HwModeRegister1_reg[10];
  assign HwModeRegister1_reg_next[12] = HwModeRegister1_reg[11];



  assign Product_cast = {1'b0, volume_ctrl_1};
  assign Product_mul_temp = Gain_out1_1 * Product_cast;
  assign Product_out1 = Product_mul_temp[77:0];


  always @(posedge clk or posedge reset)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        Product_out1_1 <= 78'sh00000000000000000000;
      end
      else begin
        if (enb) begin
          Product_out1_1 <= Product_out1;
        end
      end
    end



  assign Data_Type_Conversion1_out1 = {{6{Product_out1_1[77]}}, Product_out1_1[77:60]};


  DeltaSigma u_DeltaSigma (.clk(clk),
                           .reset(reset),
                           .enb(clk_enable),
                           .Mixed_Signal(Data_Type_Conversion1_out1),  // sfix24_En14
                           .Output_rsvd(DeltaSigma_out1)
                           );
  assign out_PDM = DeltaSigma_out1;

  assign ce_out = clk_enable;

endmodule  // audio_core

