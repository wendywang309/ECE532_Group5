// -------------------------------------------------------------
// 
// File Name: /home/shahryar/Desktop/ECE532/TestHDLMatlab/hdlsrc/audio_setup/audio_core.v
// Created: 2020-04-03 17:38:39
// 
// Generated by MATLAB 9.7 and HDL Coder 3.15
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1e-08
// Target subsystem base rate: 1e-08
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1e-08
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// out_PDM                       ce_out        1e-08
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: audio_core
// Source Path: audio_setup/audio_core
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module audio_core
          (clk,
           reset,
           clk_enable,
           note_c,
           note_d,
           note_e,
           note_f,
           piano_octave,
           volume_ctrl,
           drum_variation,
           run_drum,
           ce_out,
           out_PDM);


  input   clk;
  input   reset;
  input   clk_enable;
  input   note_c;
  input   note_d;
  input   note_e;
  input   note_f;
  input   piano_octave;
  input   [7:0] volume_ctrl;  // ufix8_En8
  input   drum_variation;
  input   run_drum;
  output  ce_out;
  output  out_PDM;


  wire enb;
  reg  [0:9] delayMatch1_reg;  // ufix1 [10]
  wire [0:9] delayMatch1_reg_next;  // ufix1 [10]
  wire run_drum_1;
  wire switch_compare_1;
  wire Logical_Operator11_out1;
  reg  [0:9] delayMatch_reg;  // ufix1 [10]
  wire [0:9] delayMatch_reg_next;  // ufix1 [10]
  wire Logical_Operator11_out1_1;
  wire switch_compare_1_1;
  wire switch_compare_1_2;
  wire Constant1_out1;
  wire Switch10_out1;
  wire Logical_Operator_out1;
  wire signed [43:0] Drum_out1;  // sfix44_En40
  wire switch_compare_1_3;
  wire Constant10_out1;
  wire Switch11_out1;
  wire Logical_Operator10_out1;
  wire signed [31:0] Constant_out1;  // sfix32_En30
  wire signed [43:0] Drum1_out1;  // sfix44_En40
  wire signed [43:0] Switch1_out1;  // sfix44_En40
  wire signed [31:0] Data_Type_Conversion6_out1;  // sfix32_En30
  wire signed [31:0] Switch_out1;  // sfix32_En30
  wire switch_compare_1_4;
  wire Constant2_out1;
  wire Switch2_out1;
  wire Logical_Operator1_out1;
  reg [31:0] HDL_Counter4_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion5_out1;  // sfix32_En28
  wire signed [31:0] Sin3_out1;  // sfix32_En30
  wire switch_compare_1_5;
  wire Constant3_out1;
  wire Switch3_out1;
  wire Logical_Operator2_out1;
  reg [31:0] HDL_Counter1_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion3_out1;  // sfix32_En28
  wire signed [31:0] Sin2_out1;  // sfix32_En30
  wire switch_compare_1_6;
  wire Constant4_out1;
  wire Switch4_out1;
  wire Logical_Operator3_out1;
  reg [31:0] HDL_Counter2_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion2_out1;  // sfix32_En28
  wire signed [31:0] Sin1_out1;  // sfix32_En30
  wire switch_compare_1_7;
  wire Constant5_out1;
  wire Switch5_out1;
  wire Logical_Operator4_out1;
  reg [31:0] HDL_Counter3_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion4_out1;  // sfix32_En28
  wire signed [31:0] Sin_out1;  // sfix32_En30
  wire Logical_Operator9_out1;
  wire switch_compare_1_8;
  wire Constant6_out1;
  wire Switch6_out1;
  wire Logical_Operator5_out1;
  reg [31:0] HDL_Counter8_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion11_out1;  // sfix32_En28
  wire signed [31:0] Sin7_out1;  // sfix32_En30
  wire switch_compare_1_9;
  wire Constant7_out1;
  wire Switch7_out1;
  wire Logical_Operator6_out1;
  reg [31:0] HDL_Counter5_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion9_out1;  // sfix32_En28
  wire signed [31:0] Sin6_out1;  // sfix32_En30
  wire switch_compare_1_10;
  wire Constant8_out1;
  wire Switch8_out1;
  wire Logical_Operator7_out1;
  reg [31:0] HDL_Counter6_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion8_out1;  // sfix32_En28
  wire signed [31:0] Sin5_out1;  // sfix32_En30
  wire switch_compare_1_11;
  wire Constant9_out1;
  wire Switch9_out1;
  wire Logical_Operator8_out1;
  reg [31:0] HDL_Counter7_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion10_out1;  // sfix32_En28
  wire signed [31:0] Sin4_out1;  // sfix32_En30
  wire signed [34:0] Sum_add_cast;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_1;  // sfix35_En30
  wire signed [34:0] Sum_add_temp;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_2;  // sfix35_En30
  wire signed [34:0] Sum_add_temp_1;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_3;  // sfix35_En30
  wire signed [34:0] Sum_add_temp_2;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_4;  // sfix35_En30
  wire signed [34:0] Sum_add_temp_3;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_5;  // sfix35_En30
  wire signed [34:0] Sum_add_temp_4;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_6;  // sfix35_En30
  wire signed [34:0] Sum_add_temp_5;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_7;  // sfix35_En30
  wire signed [34:0] Sum_out1;  // sfix35_En30
  wire signed [69:0] Gain1_out1;  // sfix70_En65
  wire signed [31:0] Data_Type_Conversion7_out1;  // sfix32_En30
  reg signed [31:0] delayMatch2_reg [0:3];  // sfix32 [4]
  wire signed [31:0] delayMatch2_reg_next [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Data_Type_Conversion7_out1_1;  // sfix32_En30
  wire signed [32:0] Sum1_add_cast;  // sfix33_En30
  wire signed [32:0] Sum1_add_cast_1;  // sfix33_En30
  wire signed [32:0] Sum1_out1;  // sfix33_En30
  wire signed [65:0] Gain_out1;  // sfix66_En62
  reg signed [65:0] Gain_out1_1;  // sfix66_En62
  reg [7:0] HwModeRegister1_reg [0:10];  // ufix8 [11]
  wire [7:0] HwModeRegister1_reg_next [0:10];  // ufix8_En8 [11]
  wire [7:0] volume_ctrl_1;  // ufix8_En8
  wire signed [8:0] Product_cast;  // sfix9_En8
  wire signed [74:0] Product_mul_temp;  // sfix75_En70
  wire signed [73:0] Product_out1;  // sfix74_En70
  reg signed [73:0] Product_out1_1;  // sfix74_En70
  wire signed [23:0] Data_Type_Conversion1_out1;  // sfix24_En14
  wire DeltaSigma_out1;


  assign enb = clk_enable;

  always @(posedge clk or posedge reset)
    begin : delayMatch1_process
      if (reset == 1'b1) begin
        delayMatch1_reg[0] <= 1'b0;
        delayMatch1_reg[1] <= 1'b0;
        delayMatch1_reg[2] <= 1'b0;
        delayMatch1_reg[3] <= 1'b0;
        delayMatch1_reg[4] <= 1'b0;
        delayMatch1_reg[5] <= 1'b0;
        delayMatch1_reg[6] <= 1'b0;
        delayMatch1_reg[7] <= 1'b0;
        delayMatch1_reg[8] <= 1'b0;
        delayMatch1_reg[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= delayMatch1_reg_next[0];
          delayMatch1_reg[1] <= delayMatch1_reg_next[1];
          delayMatch1_reg[2] <= delayMatch1_reg_next[2];
          delayMatch1_reg[3] <= delayMatch1_reg_next[3];
          delayMatch1_reg[4] <= delayMatch1_reg_next[4];
          delayMatch1_reg[5] <= delayMatch1_reg_next[5];
          delayMatch1_reg[6] <= delayMatch1_reg_next[6];
          delayMatch1_reg[7] <= delayMatch1_reg_next[7];
          delayMatch1_reg[8] <= delayMatch1_reg_next[8];
          delayMatch1_reg[9] <= delayMatch1_reg_next[9];
        end
      end
    end

  assign run_drum_1 = delayMatch1_reg[9];
  assign delayMatch1_reg_next[0] = run_drum;
  assign delayMatch1_reg_next[1] = delayMatch1_reg[0];
  assign delayMatch1_reg_next[2] = delayMatch1_reg[1];
  assign delayMatch1_reg_next[3] = delayMatch1_reg[2];
  assign delayMatch1_reg_next[4] = delayMatch1_reg[3];
  assign delayMatch1_reg_next[5] = delayMatch1_reg[4];
  assign delayMatch1_reg_next[6] = delayMatch1_reg[5];
  assign delayMatch1_reg_next[7] = delayMatch1_reg[6];
  assign delayMatch1_reg_next[8] = delayMatch1_reg[7];
  assign delayMatch1_reg_next[9] = delayMatch1_reg[8];



  assign switch_compare_1 = run_drum_1 > 1'b0;



  assign Logical_Operator11_out1 =  ~ drum_variation;


  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg[0] <= 1'b0;
        delayMatch_reg[1] <= 1'b0;
        delayMatch_reg[2] <= 1'b0;
        delayMatch_reg[3] <= 1'b0;
        delayMatch_reg[4] <= 1'b0;
        delayMatch_reg[5] <= 1'b0;
        delayMatch_reg[6] <= 1'b0;
        delayMatch_reg[7] <= 1'b0;
        delayMatch_reg[8] <= 1'b0;
        delayMatch_reg[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
          delayMatch_reg[5] <= delayMatch_reg_next[5];
          delayMatch_reg[6] <= delayMatch_reg_next[6];
          delayMatch_reg[7] <= delayMatch_reg_next[7];
          delayMatch_reg[8] <= delayMatch_reg_next[8];
          delayMatch_reg[9] <= delayMatch_reg_next[9];
        end
      end
    end

  assign Logical_Operator11_out1_1 = delayMatch_reg[9];
  assign delayMatch_reg_next[0] = Logical_Operator11_out1;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];
  assign delayMatch_reg_next[5] = delayMatch_reg[4];
  assign delayMatch_reg_next[6] = delayMatch_reg[5];
  assign delayMatch_reg_next[7] = delayMatch_reg[6];
  assign delayMatch_reg_next[8] = delayMatch_reg[7];
  assign delayMatch_reg_next[9] = delayMatch_reg[8];



  assign switch_compare_1_1 = Logical_Operator11_out1_1 > 1'b0;



  assign switch_compare_1_2 = drum_variation > 1'b0;



  assign Constant1_out1 = 1'b0;


  assign Switch10_out1 = (switch_compare_1_2 == 1'b0 ? Constant1_out1 :
              run_drum);


  assign Logical_Operator_out1 =  ~ Switch10_out1;


  Drum u_Drum (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .enb_1(Switch10_out1),
               .rst(Logical_Operator_out1),
               .Out1(Drum_out1)  // sfix44_En40
               );
  assign switch_compare_1_3 = drum_variation > 1'b0;



  assign Constant10_out1 = 1'b0;


  assign Switch11_out1 = (switch_compare_1_3 == 1'b0 ? run_drum :
              Constant10_out1);


  assign Logical_Operator10_out1 =  ~ Switch11_out1;


  assign Constant_out1 = 32'sb00000000000000000000000000000000;


  Drum1 u_Drum1 (.clk(clk),
                 .reset(reset),
                 .enb(clk_enable),
                 .enb_1(Switch11_out1),
                 .rst(Logical_Operator10_out1),
                 .Out1(Drum1_out1)  // sfix44_En40
                 );
  assign Switch1_out1 = (switch_compare_1_1 == 1'b0 ? Drum_out1 :
              Drum1_out1);


  assign Data_Type_Conversion6_out1 = Switch1_out1[41:10];


  assign Switch_out1 = (switch_compare_1 == 1'b0 ? Constant_out1 :
              Data_Type_Conversion6_out1);


  assign switch_compare_1_4 = piano_octave > 1'b0;



  assign Constant2_out1 = 1'b0;


  assign Switch2_out1 = (switch_compare_1_4 == 1'b0 ? Constant2_out1 :
              note_c);


  assign Logical_Operator1_out1 =  ~ Switch2_out1;


  // Count limited, Unsigned Counter
  //  initial value   = 3451654029
  //  step value      = 4413
  //  count to value  = 843313268
  always @(posedge clk or posedge reset)
    begin : HDL_Counter4_process
      if (reset == 1'b1) begin
        HDL_Counter4_out1 <= 32'b11001101101111000000111110001101;
      end
      else begin
        if (enb) begin
          if (Logical_Operator1_out1 == 1'b1) begin
            HDL_Counter4_out1 <= 32'b11001101101111000000111110001101;
          end
          else if (Switch2_out1 == 1'b1) begin
            if (HDL_Counter4_out1 == 32'b00110010010000111111000001110100) begin
              HDL_Counter4_out1 <= 32'b11001101101111000000111110001101;
            end
            else begin
              HDL_Counter4_out1 <= HDL_Counter4_out1 + 32'b00000000000000000001000100111101;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion5_out1 = HDL_Counter4_out1;


  Sin3 u_Sin3 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion5_out1),  // sfix32_En28
               .sin(Sin3_out1)  // sfix32_En30
               );
  assign switch_compare_1_5 = piano_octave > 1'b0;



  assign Constant3_out1 = 1'b0;


  assign Switch3_out1 = (switch_compare_1_5 == 1'b0 ? Constant3_out1 :
              note_d);


  assign Logical_Operator2_out1 =  ~ Switch3_out1;


  // Count limited, Unsigned Counter
  //  initial value   = 3451654657
  //  step value      = 4953
  //  count to value  = 843312639
  always @(posedge clk or posedge reset)
    begin : HDL_Counter1_process
      if (reset == 1'b1) begin
        HDL_Counter1_out1 <= 32'b11001101101111000001001000000001;
      end
      else begin
        if (enb) begin
          if (Logical_Operator2_out1 == 1'b1) begin
            HDL_Counter1_out1 <= 32'b11001101101111000001001000000001;
          end
          else if (Switch3_out1 == 1'b1) begin
            if (HDL_Counter1_out1 == 32'b00110010010000111110110111111111) begin
              HDL_Counter1_out1 <= 32'b11001101101111000001001000000001;
            end
            else begin
              HDL_Counter1_out1 <= HDL_Counter1_out1 + 32'b00000000000000000001001101011001;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion3_out1 = HDL_Counter1_out1;


  Sin2 u_Sin2 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion3_out1),  // sfix32_En28
               .sin(Sin2_out1)  // sfix32_En30
               );
  assign switch_compare_1_6 = piano_octave > 1'b0;



  assign Constant4_out1 = 1'b0;


  assign Switch4_out1 = (switch_compare_1_6 == 1'b0 ? Constant4_out1 :
              note_e);


  assign Logical_Operator3_out1 =  ~ Switch4_out1;


  // Count limited, Unsigned Counter
  //  initial value   = 3451654296
  //  step value      = 5560
  //  count to value  = 843313000
  always @(posedge clk or posedge reset)
    begin : HDL_Counter2_process
      if (reset == 1'b1) begin
        HDL_Counter2_out1 <= 32'b11001101101111000001000010011000;
      end
      else begin
        if (enb) begin
          if (Logical_Operator3_out1 == 1'b1) begin
            HDL_Counter2_out1 <= 32'b11001101101111000001000010011000;
          end
          else if (Switch4_out1 == 1'b1) begin
            if (HDL_Counter2_out1 == 32'b00110010010000111110111101101000) begin
              HDL_Counter2_out1 <= 32'b11001101101111000001000010011000;
            end
            else begin
              HDL_Counter2_out1 <= HDL_Counter2_out1 + 32'b00000000000000000001010110111000;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion2_out1 = HDL_Counter2_out1;


  Sin1 u_Sin1 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion2_out1),  // sfix32_En28
               .sin(Sin1_out1)  // sfix32_En30
               );
  assign switch_compare_1_7 = piano_octave > 1'b0;



  assign Constant5_out1 = 1'b0;


  assign Switch5_out1 = (switch_compare_1_7 == 1'b0 ? Constant5_out1 :
              note_f);


  assign Logical_Operator4_out1 =  ~ Switch5_out1;


  // Count limited, Unsigned Counter
  //  initial value   = 3451654766
  //  step value      = 5890
  //  count to value  = 843312530
  always @(posedge clk or posedge reset)
    begin : HDL_Counter3_process
      if (reset == 1'b1) begin
        HDL_Counter3_out1 <= 32'b11001101101111000001001001101110;
      end
      else begin
        if (enb) begin
          if (Logical_Operator4_out1 == 1'b1) begin
            HDL_Counter3_out1 <= 32'b11001101101111000001001001101110;
          end
          else if (Switch5_out1 == 1'b1) begin
            if (HDL_Counter3_out1 == 32'b00110010010000111110110110010010) begin
              HDL_Counter3_out1 <= 32'b11001101101111000001001001101110;
            end
            else begin
              HDL_Counter3_out1 <= HDL_Counter3_out1 + 32'b00000000000000000001011100000010;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion4_out1 = HDL_Counter3_out1;


  Sin u_Sin (.clk(clk),
             .reset(reset),
             .enb(clk_enable),
             .angle(Data_Type_Conversion4_out1),  // sfix32_En28
             .sin_1(Sin_out1)  // sfix32_En30
             );
  assign Logical_Operator9_out1 =  ~ piano_octave;


  assign switch_compare_1_8 = Logical_Operator9_out1 > 1'b0;



  assign Constant6_out1 = 1'b0;


  assign Switch6_out1 = (switch_compare_1_8 == 1'b0 ? Constant6_out1 :
              note_c);


  assign Logical_Operator5_out1 =  ~ Switch6_out1;


  // Count limited, Unsigned Counter
  //  initial value   = 3451655469
  //  step value      = 17651
  //  count to value  = 843311827
  always @(posedge clk or posedge reset)
    begin : HDL_Counter8_process
      if (reset == 1'b1) begin
        HDL_Counter8_out1 <= 32'b11001101101111000001010100101101;
      end
      else begin
        if (enb) begin
          if (Logical_Operator5_out1 == 1'b1) begin
            HDL_Counter8_out1 <= 32'b11001101101111000001010100101101;
          end
          else if (Switch6_out1 == 1'b1) begin
            if (HDL_Counter8_out1 == 32'b00110010010000111110101011010011) begin
              HDL_Counter8_out1 <= 32'b11001101101111000001010100101101;
            end
            else begin
              HDL_Counter8_out1 <= HDL_Counter8_out1 + 32'b00000000000000000100010011110011;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion11_out1 = HDL_Counter8_out1;


  Sin7 u_Sin7 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion11_out1),  // sfix32_En28
               .sin(Sin7_out1)  // sfix32_En30
               );
  assign switch_compare_1_9 = Logical_Operator9_out1 > 1'b0;



  assign Constant7_out1 = 1'b0;


  assign Switch7_out1 = (switch_compare_1_9 == 1'b0 ? Constant7_out1 :
              note_d);


  assign Logical_Operator6_out1 =  ~ Switch7_out1;


  // Count limited, Unsigned Counter
  //  initial value   = 3451659610
  //  step value      = 19812
  //  count to value  = 843307686
  always @(posedge clk or posedge reset)
    begin : HDL_Counter5_process
      if (reset == 1'b1) begin
        HDL_Counter5_out1 <= 32'b11001101101111000010010101011010;
      end
      else begin
        if (enb) begin
          if (Logical_Operator6_out1 == 1'b1) begin
            HDL_Counter5_out1 <= 32'b11001101101111000010010101011010;
          end
          else if (Switch7_out1 == 1'b1) begin
            if (HDL_Counter5_out1 == 32'b00110010010000111101101010100110) begin
              HDL_Counter5_out1 <= 32'b11001101101111000010010101011010;
            end
            else begin
              HDL_Counter5_out1 <= HDL_Counter5_out1 + 32'b00000000000000000100110101100100;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion9_out1 = HDL_Counter5_out1;


  Sin6 u_Sin6 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion9_out1),  // sfix32_En28
               .sin(Sin6_out1)  // sfix32_En30
               );
  assign switch_compare_1_10 = Logical_Operator9_out1 > 1'b0;



  assign Constant8_out1 = 1'b0;


  assign Switch8_out1 = (switch_compare_1_10 == 1'b0 ? Constant8_out1 :
              note_e);


  assign Logical_Operator7_out1 =  ~ Switch8_out1;


  // Count limited, Unsigned Counter
  //  initial value   = 3451657860
  //  step value      = 22238
  //  count to value  = 843309436
  always @(posedge clk or posedge reset)
    begin : HDL_Counter6_process
      if (reset == 1'b1) begin
        HDL_Counter6_out1 <= 32'b11001101101111000001111010000100;
      end
      else begin
        if (enb) begin
          if (Logical_Operator7_out1 == 1'b1) begin
            HDL_Counter6_out1 <= 32'b11001101101111000001111010000100;
          end
          else if (Switch8_out1 == 1'b1) begin
            if (HDL_Counter6_out1 == 32'b00110010010000111110000101111100) begin
              HDL_Counter6_out1 <= 32'b11001101101111000001111010000100;
            end
            else begin
              HDL_Counter6_out1 <= HDL_Counter6_out1 + 32'b00000000000000000101011011011110;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion8_out1 = HDL_Counter6_out1;


  Sin5 u_Sin5 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion8_out1),  // sfix32_En28
               .sin(Sin5_out1)  // sfix32_En30
               );
  assign switch_compare_1_11 = Logical_Operator9_out1 > 1'b0;



  assign Constant9_out1 = 1'b0;


  assign Switch9_out1 = (switch_compare_1_11 == 1'b0 ? Constant9_out1 :
              note_f);


  assign Logical_Operator8_out1 =  ~ Switch9_out1;


  // Count limited, Unsigned Counter
  //  initial value   = 3451660204
  //  step value      = 23561
  //  count to value  = 843307093
  always @(posedge clk or posedge reset)
    begin : HDL_Counter7_process
      if (reset == 1'b1) begin
        HDL_Counter7_out1 <= 32'b11001101101111000010011110101100;
      end
      else begin
        if (enb) begin
          if (Logical_Operator8_out1 == 1'b1) begin
            HDL_Counter7_out1 <= 32'b11001101101111000010011110101100;
          end
          else if (Switch9_out1 == 1'b1) begin
            if (HDL_Counter7_out1 == 32'b00110010010000111101100001010101) begin
              HDL_Counter7_out1 <= 32'b11001101101111000010011110101100;
            end
            else begin
              HDL_Counter7_out1 <= HDL_Counter7_out1 + 32'b00000000000000000101110000001001;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion10_out1 = HDL_Counter7_out1;


  Sin4_block1 u_Sin4 (.clk(clk),
                      .reset(reset),
                      .enb(clk_enable),
                      .angle(Data_Type_Conversion10_out1),  // sfix32_En28
                      .sin(Sin4_out1)  // sfix32_En30
                      );
  assign Sum_add_cast = {{3{Sin3_out1[31]}}, Sin3_out1};
  assign Sum_add_cast_1 = {{3{Sin2_out1[31]}}, Sin2_out1};
  assign Sum_add_temp = Sum_add_cast + Sum_add_cast_1;
  assign Sum_add_cast_2 = {{3{Sin1_out1[31]}}, Sin1_out1};
  assign Sum_add_temp_1 = Sum_add_temp + Sum_add_cast_2;
  assign Sum_add_cast_3 = {{3{Sin_out1[31]}}, Sin_out1};
  assign Sum_add_temp_2 = Sum_add_temp_1 + Sum_add_cast_3;
  assign Sum_add_cast_4 = {{3{Sin7_out1[31]}}, Sin7_out1};
  assign Sum_add_temp_3 = Sum_add_temp_2 + Sum_add_cast_4;
  assign Sum_add_cast_5 = {{3{Sin6_out1[31]}}, Sin6_out1};
  assign Sum_add_temp_4 = Sum_add_temp_3 + Sum_add_cast_5;
  assign Sum_add_cast_6 = {{3{Sin5_out1[31]}}, Sin5_out1};
  assign Sum_add_temp_5 = Sum_add_temp_4 + Sum_add_cast_6;
  assign Sum_add_cast_7 = {{3{Sin4_out1[31]}}, Sin4_out1};
  assign Sum_out1 = Sum_add_temp_5 + Sum_add_cast_7;


  assign Gain1_out1 = {{2{Sum_out1[34]}}, {Sum_out1, 33'b000000000000000000000000000000000}};


  assign Data_Type_Conversion7_out1 = Gain1_out1[66:35];


  always @(posedge clk or posedge reset)
    begin : delayMatch2_process
      if (reset == 1'b1) begin
        delayMatch2_reg[0] <= 32'sb00000000000000000000000000000000;
        delayMatch2_reg[1] <= 32'sb00000000000000000000000000000000;
        delayMatch2_reg[2] <= 32'sb00000000000000000000000000000000;
        delayMatch2_reg[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch2_reg[0] <= delayMatch2_reg_next[0];
          delayMatch2_reg[1] <= delayMatch2_reg_next[1];
          delayMatch2_reg[2] <= delayMatch2_reg_next[2];
          delayMatch2_reg[3] <= delayMatch2_reg_next[3];
        end
      end
    end

  assign Data_Type_Conversion7_out1_1 = delayMatch2_reg[3];
  assign delayMatch2_reg_next[0] = Data_Type_Conversion7_out1;
  assign delayMatch2_reg_next[1] = delayMatch2_reg[0];
  assign delayMatch2_reg_next[2] = delayMatch2_reg[1];
  assign delayMatch2_reg_next[3] = delayMatch2_reg[2];



  assign Sum1_add_cast = {Switch_out1[31], Switch_out1};
  assign Sum1_add_cast_1 = {Data_Type_Conversion7_out1_1[31], Data_Type_Conversion7_out1_1};
  assign Sum1_out1 = Sum1_add_cast + Sum1_add_cast_1;


  assign Gain_out1 = {{2{Sum1_out1[32]}}, {Sum1_out1, 31'b0000000000000000000000000000000}};


  always @(posedge clk or posedge reset)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        Gain_out1_1 <= 66'sh00000000000000000;
      end
      else begin
        if (enb) begin
          Gain_out1_1 <= Gain_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        HwModeRegister1_reg[0] <= 8'b00000000;
        HwModeRegister1_reg[1] <= 8'b00000000;
        HwModeRegister1_reg[2] <= 8'b00000000;
        HwModeRegister1_reg[3] <= 8'b00000000;
        HwModeRegister1_reg[4] <= 8'b00000000;
        HwModeRegister1_reg[5] <= 8'b00000000;
        HwModeRegister1_reg[6] <= 8'b00000000;
        HwModeRegister1_reg[7] <= 8'b00000000;
        HwModeRegister1_reg[8] <= 8'b00000000;
        HwModeRegister1_reg[9] <= 8'b00000000;
        HwModeRegister1_reg[10] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          HwModeRegister1_reg[0] <= HwModeRegister1_reg_next[0];
          HwModeRegister1_reg[1] <= HwModeRegister1_reg_next[1];
          HwModeRegister1_reg[2] <= HwModeRegister1_reg_next[2];
          HwModeRegister1_reg[3] <= HwModeRegister1_reg_next[3];
          HwModeRegister1_reg[4] <= HwModeRegister1_reg_next[4];
          HwModeRegister1_reg[5] <= HwModeRegister1_reg_next[5];
          HwModeRegister1_reg[6] <= HwModeRegister1_reg_next[6];
          HwModeRegister1_reg[7] <= HwModeRegister1_reg_next[7];
          HwModeRegister1_reg[8] <= HwModeRegister1_reg_next[8];
          HwModeRegister1_reg[9] <= HwModeRegister1_reg_next[9];
          HwModeRegister1_reg[10] <= HwModeRegister1_reg_next[10];
        end
      end
    end

  assign volume_ctrl_1 = HwModeRegister1_reg[10];
  assign HwModeRegister1_reg_next[0] = volume_ctrl;
  assign HwModeRegister1_reg_next[1] = HwModeRegister1_reg[0];
  assign HwModeRegister1_reg_next[2] = HwModeRegister1_reg[1];
  assign HwModeRegister1_reg_next[3] = HwModeRegister1_reg[2];
  assign HwModeRegister1_reg_next[4] = HwModeRegister1_reg[3];
  assign HwModeRegister1_reg_next[5] = HwModeRegister1_reg[4];
  assign HwModeRegister1_reg_next[6] = HwModeRegister1_reg[5];
  assign HwModeRegister1_reg_next[7] = HwModeRegister1_reg[6];
  assign HwModeRegister1_reg_next[8] = HwModeRegister1_reg[7];
  assign HwModeRegister1_reg_next[9] = HwModeRegister1_reg[8];
  assign HwModeRegister1_reg_next[10] = HwModeRegister1_reg[9];



  assign Product_cast = {1'b0, volume_ctrl_1};
  assign Product_mul_temp = Gain_out1_1 * Product_cast;
  assign Product_out1 = Product_mul_temp[73:0];


  always @(posedge clk or posedge reset)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        Product_out1_1 <= 74'sh0000000000000000000;
      end
      else begin
        if (enb) begin
          Product_out1_1 <= Product_out1;
        end
      end
    end



  assign Data_Type_Conversion1_out1 = {{6{Product_out1_1[73]}}, Product_out1_1[73:56]};


  DeltaSigma u_DeltaSigma (.clk(clk),
                           .reset(reset),
                           .enb(clk_enable),
                           .Mixed_Signal(Data_Type_Conversion1_out1),  // sfix24_En14
                           .Output_rsvd(DeltaSigma_out1)
                           );
  assign out_PDM = DeltaSigma_out1;

  assign ce_out = clk_enable;

endmodule  // audio_core

