// -------------------------------------------------------------
// 
// File Name: /home/shahryar/Desktop/ECE532/TestHDLMatlab/hdlsrc/test2/HDL_DUT.v
// Created: 2020-03-19 04:12:17
// 
// Generated by MATLAB 9.7 and HDL Coder 3.15
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1e-08
// Target subsystem base rate: 1e-08
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1e-08
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// out1                          ce_out        1e-08
// out                           ce_out        1e-08
// out2                          ce_out        1e-08
// out3                          ce_out        1e-08
// out4                          ce_out        1e-08
// Integrator                    ce_out        1e-08
// Unmodulated                   ce_out        1e-08
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: HDL_DUT
// Source Path: test2/HDL_DUT
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module HDL_DUT
          (clk,
           reset,
           clk_enable,
           Input1,
           Input2,
           Input3,
           Input4,
           run_drum,
           ce_out,
           out1,
           out,
           out2,
           out3,
           out4,
           Integrator,
           Unmodulated);


  input   clk;
  input   reset;
  input   clk_enable;
  input   Input1;
  input   Input2;
  input   Input3;
  input   Input4;
  input   run_drum;
  output  ce_out;
  output  out1;
  output  signed [31:0] out;  // sfix32_En30
  output  signed [31:0] out2;  // sfix32_En30
  output  signed [31:0] out3;  // sfix32_En30
  output  signed [31:0] out4;  // sfix32_En30
  output  signed [23:0] Integrator;  // sfix24_En14
  output  signed [23:0] Unmodulated;  // sfix24_En14


  wire enb;
  wire signed [34:0] kconst;  // sfix35_En36
  reg signed [34:0] kconst_1;  // sfix35_En36
  reg  [0:9] delayMatch_reg;  // ufix1 [10]
  wire [0:9] delayMatch_reg_next;  // ufix1 [10]
  wire run_drum_1;
  wire switch_compare_1;
  wire Logical_Operator_out1;
  wire signed [31:0] Constant_out1;  // sfix32_En30
  wire signed [43:0] Drum_out1;  // sfix44_En40
  wire signed [31:0] Data_Type_Conversion6_out1;  // sfix32_En30
  wire signed [31:0] Switch_out1;  // sfix32_En30
  wire Logical_Operator1_out1;
  reg [31:0] HDL_Counter4_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion5_out1;  // sfix32_En28
  wire signed [31:0] Sin3_out1;  // sfix32_En30
  reg signed [31:0] reduced_reg [0:3];  // sfix32 [4]
  wire signed [31:0] reduced_reg_next [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Sin3_out1_1;  // sfix32_En30
  wire Logical_Operator2_out1;
  reg [31:0] HDL_Counter1_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion3_out1;  // sfix32_En28
  wire signed [31:0] Sin2_out1;  // sfix32_En30
  reg signed [31:0] reduced_reg_1 [0:3];  // sfix32 [4]
  wire signed [31:0] reduced_reg_next_1 [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Sin2_out1_1;  // sfix32_En30
  wire Logical_Operator3_out1;
  reg [31:0] HDL_Counter2_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion2_out1;  // sfix32_En28
  wire signed [31:0] Sin1_out1;  // sfix32_En30
  reg signed [31:0] reduced_reg_2 [0:3];  // sfix32 [4]
  wire signed [31:0] reduced_reg_next_2 [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Sin1_out1_1;  // sfix32_En30
  wire Logical_Operator4_out1;
  reg [31:0] HDL_Counter3_out1;  // uint32
  wire signed [31:0] Data_Type_Conversion4_out1;  // sfix32_En28
  wire signed [31:0] Sin_out1;  // sfix32_En30
  reg signed [31:0] reduced_reg_3 [0:3];  // sfix32 [4]
  wire signed [31:0] reduced_reg_next_3 [0:3];  // sfix32_En30 [4]
  wire signed [31:0] Sin_out1_1;  // sfix32_En30
  wire signed [34:0] Sum_add_cast;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_1;  // sfix35_En30
  wire signed [34:0] Sum_add_temp;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_2;  // sfix35_En30
  wire signed [34:0] Sum_add_temp_1;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_3;  // sfix35_En30
  wire signed [34:0] Sum_add_temp_2;  // sfix35_En30
  wire signed [34:0] Sum_add_cast_4;  // sfix35_En30
  wire signed [34:0] Sum_out1;  // sfix35_En30
  reg signed [34:0] Sum_out1_1;  // sfix35_En30
  wire signed [69:0] Gain_out1;  // sfix70_En66
  reg signed [69:0] Gain_out1_1;  // sfix70_En66
  wire signed [23:0] Data_Type_Conversion1_out1;  // sfix24_En14
  wire DeltaSigma_out1;
  wire signed [23:0] DeltaSigma_out2;  // sfix24_En14
  wire signed [23:0] DeltaSigma_out3;  // sfix24_En14
  reg signed [31:0] reduced_reg_4 [0:1];  // sfix32 [2]
  wire signed [31:0] reduced_reg_next_4 [0:1];  // sfix32_En30 [2]
  wire signed [31:0] Sin_out1_2;  // sfix32_En30
  reg signed [31:0] reduced_reg_5 [0:1];  // sfix32 [2]
  wire signed [31:0] reduced_reg_next_5 [0:1];  // sfix32_En30 [2]
  wire signed [31:0] Sin1_out1_2;  // sfix32_En30
  reg signed [31:0] reduced_reg_6 [0:1];  // sfix32 [2]
  wire signed [31:0] reduced_reg_next_6 [0:1];  // sfix32_En30 [2]
  wire signed [31:0] Sin2_out1_2;  // sfix32_En30
  reg signed [31:0] reduced_reg_7 [0:1];  // sfix32 [2]
  wire signed [31:0] reduced_reg_next_7 [0:1];  // sfix32_En30 [2]
  wire signed [31:0] Sin3_out1_2;  // sfix32_En30


  assign kconst = 35'sh333333333;



  assign enb = clk_enable;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        kconst_1 <= 35'sh000000000;
      end
      else begin
        if (enb) begin
          kconst_1 <= kconst;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg[0] <= 1'b0;
        delayMatch_reg[1] <= 1'b0;
        delayMatch_reg[2] <= 1'b0;
        delayMatch_reg[3] <= 1'b0;
        delayMatch_reg[4] <= 1'b0;
        delayMatch_reg[5] <= 1'b0;
        delayMatch_reg[6] <= 1'b0;
        delayMatch_reg[7] <= 1'b0;
        delayMatch_reg[8] <= 1'b0;
        delayMatch_reg[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
          delayMatch_reg[5] <= delayMatch_reg_next[5];
          delayMatch_reg[6] <= delayMatch_reg_next[6];
          delayMatch_reg[7] <= delayMatch_reg_next[7];
          delayMatch_reg[8] <= delayMatch_reg_next[8];
          delayMatch_reg[9] <= delayMatch_reg_next[9];
        end
      end
    end

  assign run_drum_1 = delayMatch_reg[9];
  assign delayMatch_reg_next[0] = run_drum;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];
  assign delayMatch_reg_next[5] = delayMatch_reg[4];
  assign delayMatch_reg_next[6] = delayMatch_reg[5];
  assign delayMatch_reg_next[7] = delayMatch_reg[6];
  assign delayMatch_reg_next[8] = delayMatch_reg[7];
  assign delayMatch_reg_next[9] = delayMatch_reg[8];



  assign switch_compare_1 = run_drum_1 > 1'b0;



  assign Logical_Operator_out1 =  ~ run_drum;


  assign Constant_out1 = 32'sb00000000000000000000000000000000;


  Drum u_Drum (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .enb_1(run_drum),
               .rst(Logical_Operator_out1),
               .Out1(Drum_out1)  // sfix44_En40
               );
  assign Data_Type_Conversion6_out1 = Drum_out1[41:10];


  assign Switch_out1 = (switch_compare_1 == 1'b0 ? Constant_out1 :
              Data_Type_Conversion6_out1);


  assign Logical_Operator1_out1 =  ~ Input1;


  // Count limited, Unsigned Counter
  //  initial value   = 3451655469
  //  step value      = 17651
  //  count to value  = 843311827
  always @(posedge clk or posedge reset)
    begin : HDL_Counter4_process
      if (reset == 1'b1) begin
        HDL_Counter4_out1 <= 32'b11001101101111000001010100101101;
      end
      else begin
        if (enb) begin
          if (Logical_Operator1_out1 == 1'b1) begin
            HDL_Counter4_out1 <= 32'b11001101101111000001010100101101;
          end
          else if (Input1 == 1'b1) begin
            if (HDL_Counter4_out1 == 32'b00110010010000111110101011010011) begin
              HDL_Counter4_out1 <= 32'b11001101101111000001010100101101;
            end
            else begin
              HDL_Counter4_out1 <= HDL_Counter4_out1 + 32'b00000000000000000100010011110011;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion5_out1 = HDL_Counter4_out1;


  Sin3 u_Sin3 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion5_out1),  // sfix32_En28
               .sin(Sin3_out1)  // sfix32_En30
               );
  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        reduced_reg[0] <= 32'sb00000000000000000000000000000000;
        reduced_reg[1] <= 32'sb00000000000000000000000000000000;
        reduced_reg[2] <= 32'sb00000000000000000000000000000000;
        reduced_reg[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg[0] <= reduced_reg_next[0];
          reduced_reg[1] <= reduced_reg_next[1];
          reduced_reg[2] <= reduced_reg_next[2];
          reduced_reg[3] <= reduced_reg_next[3];
        end
      end
    end

  assign Sin3_out1_1 = reduced_reg[3];
  assign reduced_reg_next[0] = Sin3_out1;
  assign reduced_reg_next[1] = reduced_reg[0];
  assign reduced_reg_next[2] = reduced_reg[1];
  assign reduced_reg_next[3] = reduced_reg[2];



  assign Logical_Operator2_out1 =  ~ Input2;


  // Count limited, Unsigned Counter
  //  initial value   = 3451659610
  //  step value      = 19812
  //  count to value  = 843307686
  always @(posedge clk or posedge reset)
    begin : HDL_Counter1_process
      if (reset == 1'b1) begin
        HDL_Counter1_out1 <= 32'b11001101101111000010010101011010;
      end
      else begin
        if (enb) begin
          if (Logical_Operator2_out1 == 1'b1) begin
            HDL_Counter1_out1 <= 32'b11001101101111000010010101011010;
          end
          else if (Input2 == 1'b1) begin
            if (HDL_Counter1_out1 == 32'b00110010010000111101101010100110) begin
              HDL_Counter1_out1 <= 32'b11001101101111000010010101011010;
            end
            else begin
              HDL_Counter1_out1 <= HDL_Counter1_out1 + 32'b00000000000000000100110101100100;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion3_out1 = HDL_Counter1_out1;


  Sin2 u_Sin2 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion3_out1),  // sfix32_En28
               .sin(Sin2_out1)  // sfix32_En30
               );
  always @(posedge clk or posedge reset)
    begin : reduced_1_process
      if (reset == 1'b1) begin
        reduced_reg_1[0] <= 32'sb00000000000000000000000000000000;
        reduced_reg_1[1] <= 32'sb00000000000000000000000000000000;
        reduced_reg_1[2] <= 32'sb00000000000000000000000000000000;
        reduced_reg_1[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg_1[0] <= reduced_reg_next_1[0];
          reduced_reg_1[1] <= reduced_reg_next_1[1];
          reduced_reg_1[2] <= reduced_reg_next_1[2];
          reduced_reg_1[3] <= reduced_reg_next_1[3];
        end
      end
    end

  assign Sin2_out1_1 = reduced_reg_1[3];
  assign reduced_reg_next_1[0] = Sin2_out1;
  assign reduced_reg_next_1[1] = reduced_reg_1[0];
  assign reduced_reg_next_1[2] = reduced_reg_1[1];
  assign reduced_reg_next_1[3] = reduced_reg_1[2];



  assign Logical_Operator3_out1 =  ~ Input3;


  // Count limited, Unsigned Counter
  //  initial value   = 3451657860
  //  step value      = 22238
  //  count to value  = 843309436
  always @(posedge clk or posedge reset)
    begin : HDL_Counter2_process
      if (reset == 1'b1) begin
        HDL_Counter2_out1 <= 32'b11001101101111000001111010000100;
      end
      else begin
        if (enb) begin
          if (Logical_Operator3_out1 == 1'b1) begin
            HDL_Counter2_out1 <= 32'b11001101101111000001111010000100;
          end
          else if (Input3 == 1'b1) begin
            if (HDL_Counter2_out1 == 32'b00110010010000111110000101111100) begin
              HDL_Counter2_out1 <= 32'b11001101101111000001111010000100;
            end
            else begin
              HDL_Counter2_out1 <= HDL_Counter2_out1 + 32'b00000000000000000101011011011110;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion2_out1 = HDL_Counter2_out1;


  Sin1 u_Sin1 (.clk(clk),
               .reset(reset),
               .enb(clk_enable),
               .angle(Data_Type_Conversion2_out1),  // sfix32_En28
               .sin(Sin1_out1)  // sfix32_En30
               );
  always @(posedge clk or posedge reset)
    begin : reduced_2_process
      if (reset == 1'b1) begin
        reduced_reg_2[0] <= 32'sb00000000000000000000000000000000;
        reduced_reg_2[1] <= 32'sb00000000000000000000000000000000;
        reduced_reg_2[2] <= 32'sb00000000000000000000000000000000;
        reduced_reg_2[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg_2[0] <= reduced_reg_next_2[0];
          reduced_reg_2[1] <= reduced_reg_next_2[1];
          reduced_reg_2[2] <= reduced_reg_next_2[2];
          reduced_reg_2[3] <= reduced_reg_next_2[3];
        end
      end
    end

  assign Sin1_out1_1 = reduced_reg_2[3];
  assign reduced_reg_next_2[0] = Sin1_out1;
  assign reduced_reg_next_2[1] = reduced_reg_2[0];
  assign reduced_reg_next_2[2] = reduced_reg_2[1];
  assign reduced_reg_next_2[3] = reduced_reg_2[2];



  assign Logical_Operator4_out1 =  ~ Input4;


  // Count limited, Unsigned Counter
  //  initial value   = 3451660204
  //  step value      = 23561
  //  count to value  = 843307093
  always @(posedge clk or posedge reset)
    begin : HDL_Counter3_process
      if (reset == 1'b1) begin
        HDL_Counter3_out1 <= 32'b11001101101111000010011110101100;
      end
      else begin
        if (enb) begin
          if (Logical_Operator4_out1 == 1'b1) begin
            HDL_Counter3_out1 <= 32'b11001101101111000010011110101100;
          end
          else if (Input4 == 1'b1) begin
            if (HDL_Counter3_out1 == 32'b00110010010000111101100001010101) begin
              HDL_Counter3_out1 <= 32'b11001101101111000010011110101100;
            end
            else begin
              HDL_Counter3_out1 <= HDL_Counter3_out1 + 32'b00000000000000000101110000001001;
            end
          end
        end
      end
    end


  assign Data_Type_Conversion4_out1 = HDL_Counter3_out1;


  Sin u_Sin (.clk(clk),
             .reset(reset),
             .enb(clk_enable),
             .angle(Data_Type_Conversion4_out1),  // sfix32_En28
             .sin_1(Sin_out1)  // sfix32_En30
             );
  always @(posedge clk or posedge reset)
    begin : reduced_3_process
      if (reset == 1'b1) begin
        reduced_reg_3[0] <= 32'sb00000000000000000000000000000000;
        reduced_reg_3[1] <= 32'sb00000000000000000000000000000000;
        reduced_reg_3[2] <= 32'sb00000000000000000000000000000000;
        reduced_reg_3[3] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg_3[0] <= reduced_reg_next_3[0];
          reduced_reg_3[1] <= reduced_reg_next_3[1];
          reduced_reg_3[2] <= reduced_reg_next_3[2];
          reduced_reg_3[3] <= reduced_reg_next_3[3];
        end
      end
    end

  assign Sin_out1_1 = reduced_reg_3[3];
  assign reduced_reg_next_3[0] = Sin_out1;
  assign reduced_reg_next_3[1] = reduced_reg_3[0];
  assign reduced_reg_next_3[2] = reduced_reg_3[1];
  assign reduced_reg_next_3[3] = reduced_reg_3[2];



  assign Sum_add_cast = {{3{Switch_out1[31]}}, Switch_out1};
  assign Sum_add_cast_1 = {{3{Sin3_out1_1[31]}}, Sin3_out1_1};
  assign Sum_add_temp = Sum_add_cast + Sum_add_cast_1;
  assign Sum_add_cast_2 = {{3{Sin2_out1_1[31]}}, Sin2_out1_1};
  assign Sum_add_temp_1 = Sum_add_temp + Sum_add_cast_2;
  assign Sum_add_cast_3 = {{3{Sin1_out1_1[31]}}, Sin1_out1_1};
  assign Sum_add_temp_2 = Sum_add_temp_1 + Sum_add_cast_3;
  assign Sum_add_cast_4 = {{3{Sin_out1_1[31]}}, Sin_out1_1};
  assign Sum_out1 = Sum_add_temp_2 + Sum_add_cast_4;


  always @(posedge clk or posedge reset)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        Sum_out1_1 <= 35'sh000000000;
      end
      else begin
        if (enb) begin
          Sum_out1_1 <= Sum_out1;
        end
      end
    end



  assign Gain_out1 = kconst_1 * Sum_out1_1;


  always @(posedge clk or posedge reset)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        Gain_out1_1 <= 70'sh000000000000000000;
      end
      else begin
        if (enb) begin
          Gain_out1_1 <= Gain_out1;
        end
      end
    end



  assign Data_Type_Conversion1_out1 = {{6{Gain_out1_1[69]}}, Gain_out1_1[69:52]};


  DeltaSigma u_DeltaSigma (.clk(clk),
                           .reset(reset),
                           .enb(clk_enable),
                           .Mixed_Signal(Data_Type_Conversion1_out1),  // sfix24_En14
                           .Output_rsvd(DeltaSigma_out1),
                           .Integrator(DeltaSigma_out2),  // sfix24_En14
                           .out7(DeltaSigma_out3)  // sfix24_En14
                           );
  assign out1 = DeltaSigma_out1;

  always @(posedge clk or posedge reset)
    begin : reduced_4_process
      if (reset == 1'b1) begin
        reduced_reg_4[0] <= 32'sb00000000000000000000000000000000;
        reduced_reg_4[1] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg_4[0] <= reduced_reg_next_4[0];
          reduced_reg_4[1] <= reduced_reg_next_4[1];
        end
      end
    end

  assign Sin_out1_2 = reduced_reg_4[1];
  assign reduced_reg_next_4[0] = Sin_out1_1;
  assign reduced_reg_next_4[1] = reduced_reg_4[0];



  assign out = Sin_out1_2;

  always @(posedge clk or posedge reset)
    begin : reduced_5_process
      if (reset == 1'b1) begin
        reduced_reg_5[0] <= 32'sb00000000000000000000000000000000;
        reduced_reg_5[1] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg_5[0] <= reduced_reg_next_5[0];
          reduced_reg_5[1] <= reduced_reg_next_5[1];
        end
      end
    end

  assign Sin1_out1_2 = reduced_reg_5[1];
  assign reduced_reg_next_5[0] = Sin1_out1_1;
  assign reduced_reg_next_5[1] = reduced_reg_5[0];



  assign out2 = Sin1_out1_2;

  always @(posedge clk or posedge reset)
    begin : reduced_6_process
      if (reset == 1'b1) begin
        reduced_reg_6[0] <= 32'sb00000000000000000000000000000000;
        reduced_reg_6[1] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg_6[0] <= reduced_reg_next_6[0];
          reduced_reg_6[1] <= reduced_reg_next_6[1];
        end
      end
    end

  assign Sin2_out1_2 = reduced_reg_6[1];
  assign reduced_reg_next_6[0] = Sin2_out1_1;
  assign reduced_reg_next_6[1] = reduced_reg_6[0];



  assign out3 = Sin2_out1_2;

  always @(posedge clk or posedge reset)
    begin : reduced_7_process
      if (reset == 1'b1) begin
        reduced_reg_7[0] <= 32'sb00000000000000000000000000000000;
        reduced_reg_7[1] <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg_7[0] <= reduced_reg_next_7[0];
          reduced_reg_7[1] <= reduced_reg_next_7[1];
        end
      end
    end

  assign Sin3_out1_2 = reduced_reg_7[1];
  assign reduced_reg_next_7[0] = Sin3_out1_1;
  assign reduced_reg_next_7[1] = reduced_reg_7[0];



  assign out4 = Sin3_out1_2;

  assign Integrator = DeltaSigma_out2;

  assign Unmodulated = DeltaSigma_out3;

  assign ce_out = clk_enable;

endmodule  // HDL_DUT

